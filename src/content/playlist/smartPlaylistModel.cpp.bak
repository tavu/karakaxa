#include<KIcon>
#include"smartPlaylistModel.h"
#include<QDebug>
#include<player.h>
#include<QApplication>
#define XMLFILE QString("playlists.xml")

smartPlaylistModel::smartPlaylistModel(QObject* parent)
  :QStandardItemModel(parent),
  plLIstChildrenFlag(true)
{
    QDomDocument doc;
    QFile file(player::config.saveLocation()+XMLFILE);
    plList=new folderItem("Playlist" );
//     plList->setSizeHint(QSize(30,30) );
    insertRow(0,plList);
    
    if(doc.setContent(&file,true) )
    {
	QDomNode n = doc.firstChild();
	if(n.isElement() && n.toElement().tagName()==QString("folder") )
	{
	    smTree=new folderItem(n.toElement() );
	}
	else
	{
	    smTree=new folderItem(tr("Smart playlist") );
	}	  
    }
    else
    {
	smTree=new folderItem(tr("Smart playlist") );
    }    

//     smTree->setSizeHint(QSize(30,30) );
    insertRow(1,smTree);
    
    


    
    connect(qApp,SIGNAL(aboutToQuit() ),this,SLOT(save() ) );
}

smartPlaylistModel::~smartPlaylistModel()
{
}

int smartPlaylistModel::head(QModelIndex index) const
{
    if(!index.isValid())
    {
	return -1;
    }
  
    while(index.parent().isValid() )
    {
	index=index.parent();	
    }
    return index.row();
}


QVariant smartPlaylistModel::data ( const QModelIndex & index, int role ) const
{
    QVariant var=QStandardItemModel::data(index,role);    
    
    if(role==Qt::DecorationRole && var.isNull())      
    {
	QStandardItem *i=itemFromIndex(index);
	if(i->type()==FOLDER_ITEM)
	{
	    return KIcon("folder");
	}
	else
	{
	    return KIcon("audio-x-flac");
	}
    }
    return var;    
}

bool smartPlaylistModel::remove(QModelIndex index)
{
    if(!index.isValid())
    {
	return false;
    }
    QModelIndex in=index.parent();
    if(!in.isValid() )
    {
	return false;
    }
    
            
    standardItemTree *parent=static_cast<standardItemTree*>(itemFromIndex(in) );
    standardItemTree *item=static_cast<standardItemTree*>(itemFromIndex(index) );
//     takeRow(index.row() );
    QDomElement el=parent->xml();
    el.removeChild(item->xml());
    removeRow(index.row(),in);
    
    return true;
    
}

bool smartPlaylistModel::append (standardItemTree* item, const QModelIndex& parent )
{
    if(item==0)
    {
	return false;
    }
    
    QStandardItem *father;
    
    if(parent.isValid())
    {      
	father=itemFromIndex(parent);
		
	if(father->type()!=FOLDER_ITEM )
	{
	    father=father->parent();
	    if(father==0)
	    {
		return false;
	    }
	}
    }
    else
    {
	father=smTree;
    }
    
    folderItem *f=static_cast<folderItem*>(father);
    qDebug()<<f->text();
    f->append(item);
    f->sortChildren(0);
    
//     save();
    return true;    
}

void smartPlaylistModel::save()
{
    QDomDocument doc;
    QDomElement root=doc.createElement("smartPlaylist");
    root.appendChild(smTree->xml() );
    doc.appendChild(smTree->xml());

    
    QFile file(player::config.saveLocation()+XMLFILE);
    file.copy(player::config.saveLocation()+XMLFILE+QString(".bak") );
    if ( file.open( QIODevice::WriteOnly ) ) 
    {
	QTextStream ts(&file);
	ts << doc.toString();	
	qDebug()<<doc.toString();
	file.close();
    }
    else
    {
	player::statusBar.showMessage(tr("Unable to save the playlist"));
    }
    
}
bool smartPlaylistModel::hasChildren ( const QModelIndex & parent ) const
{
    QStandardItem *item=itemFromIndex(parent);          
    if(item==0)  
    {  
      return true;        
    }
    if(item->type()!=FOLDER_ITEM )
    {
	return false;
    }
    if(item==plList)
    {
	return plLIstChildrenFlag;
    }
    	
    folderItem *f=static_cast<folderItem*>(item);		
    if(f->xml().hasChildNodes() )	
    {	    
	return true;
    }
    return false;
}

bool smartPlaylistModel::canFetchMore ( const QModelIndex & parent ) const
{
    QStandardItem *item=itemFromIndex(parent);        
    
    if(item==0)
    {
      return false;
    }
    
    if(hasChildren(parent) && item->rowCount()==0 )
    {        
	return true;
    }
    return false;
}

void smartPlaylistModel::fetchMore ( const QModelIndex & parent )
{
    QStandardItem *it=itemFromIndex(parent);
    
    if(it==plList)
    {
	fetchPlaylist();
	return ;
    }
    
    folderItem *f=static_cast<folderItem*>(it );
    
    QDomElement folderElement=f->xml();
    
    
    for(QDomElement el = folderElement.firstChildElement(); !el.isNull(); el = el.nextSiblingElement())
    {
	if(el.tagName()==QString("smartPlaylist") )
	{
	    smplaylistItem *i=new smplaylistItem(el.attribute("name","Unnamed") );
	    i->setXmlElement(el);
	    f->appendRow(i);
	}
	else if(el.tagName()==QString("folder") )
	{
	    folderItem *i=new folderItem(el);
	    f->appendRow(i);
	}
    }
    f->sortChildren(0);
}

void smartPlaylistModel::fetchPlaylist()
{
    QSqlQuery q=db.playlists();
     plLIstChildrenFlag=false;
     while (q.next())
     {
	  playlistItem *item=new playlistItem(q.value(0).toString() );
	  plList->appendRow(item);
	  plLIstChildrenFlag=true;
     }
     dataChanged(plList->index(),plList->index());
}

smplaylistItem::smplaylistItem(const QString &text)
  :standardItemTree(text)
{
}

void smplaylistItem::generateQuery() const
{
    QString q;
    for(QDomNode n = element.firstChild(); !n.isNull(); n = n.nextSiblingElement("group"))
    {      
	for(QDomNode nod=n.firstChild(); !nod.isNull(); nod=n.nextSibling() )
	{	    
	    if(n.nodeName()==QString("group") )
	    {
		_query +=group(n);
	    }
	}
    }
}

int smplaylistItem::type () const
{
    return SMARTPL_ITEM;
}


QString smplaylistItem::group(QDomNode nod) const
{
    QString q;
    QStringList l;
    for(QDomNode n=nod.firstChild(); !n.isNull(); n=n.nextSibling() )	
    {
	QString name=n.nodeName();
	
	if(name==QString("group") )
	{
	    q+=group(n);
	}
	else if(name==QString("field") )
	{
	    QString s, q;
	    bool invert;
	    player::tagsEnum t;
	    queryGrt::equal comp;

	    QDomElement e=n.toElement();
	    s=e.attribute("tag");
	    
	    t=(tagsEnum)s.toInt();
	    
	    s=e.attribute("comparison");
	    comp=(queryGrt::equal)s.toInt();
	    
	    s=e.attribute("invert");
	    invert=(bool)s.toInt();
	    
	    s=e.attribute("value");
	    
	    l<<queryGrt::query(t,comp,s,invert);
	}		
    }
    
    QDomElement e=nod.toElement();
    QString s=e.attribute("matchtype");
    
    if(s==QString("all") )
    {
	q+=queryGrt::connectAnd(l);
    }
    else if(s==QString("any") )
    {
      q+=queryGrt::connectOr(l);
    }
    
    return q;    
}

QDomElement smplaylistItem::xml() const
{
    return element;
}

QVariant smplaylistItem::data ( int role  ) const 
{
    if(role==ITEM_ROLE)
    {
	return QVariant(query());
    }
    return standardItemTree::data(role);
}


folderItem::folderItem(const QString &text)
    :standardItemTree(text)
{
     QDomDocument doc;
     element=doc.createElement("folder");
//     element.setTagName("folder");
    element.setAttribute("name",text );
}

folderItem::folderItem(const QDomElement &el)
    :standardItemTree()
{ 
    element=el;
    setText(el.attribute("name","Unnamed"));
}

void folderItem::setData ( const QVariant & value, int role )
{    
	element.setAttribute("name",value.toString() );
	standardItemTree::setData(value,role);	
}

int folderItem::type () const
{
    return FOLDER_ITEM;
}

QDomElement folderItem::xml() const
{
  return element;
}

void folderItem::append (standardItemTree* item )
{
    QDomElement el=item->xml();
    
    if(!el.isNull() )
    {
      element.appendChild(el);
    }
    appendRow(item);
}


	
standardItemTree::standardItemTree(const QString &text)
    :QStandardItem(text)	
{}

standardItemTree::standardItemTree()
    :QStandardItem()
{}


QVariant standardItemTree::data( int role) const
{
    return QStandardItem::data(role);
}

standardItemTree::~standardItemTree()
{}

playlistItem::playlistItem(const QString &path)
    :standardItemTree(path)
{
    setText(player::titleFromPath(path) );
    this->path=path;
}

QVariant playlistItem::data(int role) const
{
    if(role==ITEM_ROLE)
    {
	return QVariant(path);
    }
    return standardItemTree::data(role);
}

QDomElement playlistItem::xml() const
{
    return QDomElement();
}

int playlistItem::type () const
{
    return PLAYLIST_ITEM;
}

